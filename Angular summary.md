Angular Summary
=====================
# Angular의 컨셉

## Angular 개요

HTML+Typescript                             	클라이언트 어플리케이션 개발

Angular 어플리케이션 중 가장 중요한 것은             컴포넌트 묶음인 Ngmodule

                                                               -비슷한 기능을 하나로 묶어 관리하기 위한 모듈


컴포넌트를 뷰를 정의하고 화면에 어떤 엘리먼트가 어떤 데이터를

표시할 것인지 지정함.


컴포넌트는 서비스를 활용함.

뷰와 직접 관련있지 않은 기능은 컴포넌트에 있을 필요가 없으며,

(이런 로직은 서비스에 정의하고) 컴포넌트에 의존성으로 주입해서           뷰와관련없는 로직은 서비스에 정의하고 의존성을 주입해서 활용

사용하면 코드를 모듈단위로 관리할 수 있기 때문에 재사용하기

편하고 훨씬 효율적임



컴포넌트와 서비스는 단순한 클래스지만, 데코레이터와 메타데이터를 사용해

이 클래스에서 Angular가 어떤 역할을 할지 지정할 수 있음.

컴포넌트 클래스에 메타데이터를 지정하면 템플릿을 뷰로 지정할 수 있음.                   -메타데이터?
 
템플릿은 일반적인 HTML 문법을 바탕으로 Angular가 지정하는 디렉티브와

바인딩 마크업을 사용. 이 템플릿은 Angular에서 처리한 후에 화면에 랜더링됨.

서비스 클래스에 메타데이터를 지정하면 Angular 컴포넌트에 의존성으로 주입할

수 있음.




Angular 어플리케이션에서는 여러 뷰를 계층으로 구성하고

Router 서비스를 통해 이 뷰들을 전환하며 페이지를 이동할 수 있음.

(브라우저의 페이지 전환 로직을 활용)




## 모듈


Angular는 Javascript와(ES2015) 모듈과 다르며 서로 보완적인 Ngmodule 체계를 

마련함.

Ngmodule은 기능적으로 관련되거나 작업 흐름이 연관된 컴포넌트를 묶어서 선언함.

그리고 컴포넌트 외에 서비스나 폼 기능을 포함하기도 함.


모든 Angular 앱에는 Appmodule이라는 이름으로 선언하는 최상위 모듈이 존재.

애플리케이션의 부트스트랩 방법은 이 모듈에서 지정하며 이 모듈아래로 여러 기능 포함 가능.

Javascript 모듈과 비슷하게 Ngmodule도 다른 Ngmodule을 불러오거나 다른 Ngmoduel을 위해

모듈의 기능 일부를 외부로 공개 가능.

예를 들면 애플리케이션에서 라우터 서비스를 사용하려면 Router Ngmodule을 불러와야 함.

비슷한 코드를 하나의 기능 모듈로 관리하면 코드를 더 효율적으로 관리 할 수 있으며,

이렇게 만든 모듈은 재사용 측면에서 더 효율적이며 복잡한 어플리케이션을 개발할 수록

체감할 수 있는 효율이 증가함.

그리고 코드를 모듈로 관리하면 애플리케이션이 실행될때 모든 모듈을 한번에 불러오지 않고

필요할때 불러오는 지연로딩을 활용할 때도 유리함.

지연로딩을 활용하면 어플리케이션의 초기 로딩 속도를 최소화할 수 있음.



## 컴포넌트

Angular 애플리케이션에는 페이지 DOM의 최상위에 위치하는 컴포넌트가 존재하는데,

이 컴포넌트를 최상위 컴포넌트라고 한다. 그리고 모든 컴포넌트는 컴포넌트 클래스와

템플릿으로 구성하는데,

컴포넌트 클래스는 애플리케이션 데이터와 로직을 처리하고 템플릿은 

화면에 표시할 HTML을 정의한다.


Angular 컴포넌트는 컴포넌트 클래스에 @Component() 데코레이터를 사용해

컴포넌트에 대한 메타데이터를 지정하며 템플릿도 함께 지정한다.

- 데코레이터는 Javascript 클래스를 변형하는 함수이다.

   Angular에서 제공하는 데코레이터를 어떻게 사용하는지에 따라 클래스의 동작이 달라진다.


- 템플릿, 디렉티브, 데이터 바인딩

  템플릿은 HTML 문법과 Angular 마크업 문법을 조합해 구성한다.

  Angular 마크 업 문법은 HTML 엘리먼트를 확장하는 역할을 한다.

  템플릿에 디렉티브를 사용하면 원하는 동작을 하도록 확장할 수 있고

  


왜 서비스를 사용할까요?
컴포넌트는 데이터를 직접 가져오거나 직접 저장하도록 요청하지 않는 것이 좋습니다. 

그리고 사용하는 데이터가 실제 데이터인지 가짜 데이터인지 알 필요도 없습니다. 

컴포넌트는 데이터를 표시하는 것에만 집중하는 것이 좋으며,                                                      컴포넌트는 데이터를 표시하는 것에만 집중,  
                                                                                                                                데이터를 처리하는 로직은 서비스에 집중
데이터를 처리하는 로직은 서비스에게 맡겨두는 것이 좋습니다.

## 서비스에 관하여
컴포넌트를 뷰(View)를 생성하고 관리하는 것이 주된 역할이다.
 하지만 컴포넌트를 작성하다 보면 컴포넌트 내에 컴포넌트의 주 관심사 이외의 부가적인 기능
(예를 들어 로깅 기능, 서버 통신 기능 등)이 필요하게 된다. 

이때 컴포넌트의 주 관심사 이외의 부가적 기능을 컴포넌트 내에 작성하면 부가적 기능이 변경되었을 때 
컴포넌트 또한 변경되어야 하며 재사용이 어려워진다. 

이처럼 자신의 관심사에 집중하는 독립성이 보장된 코드의 작성이 어려워지면 
코드가 중복되어 재사용성이 낮아지고 복잡도는 높아진다.

자신의 주요 관심사 이외의 부가적인 기능은 애플리케이션 전역의 관심사인 경우가 많다.
 이러한 경우, 컴포넌트의 관심사와 애플리케이션 전역의 관심사를 분리하는 것이 필요한데 
이때 사용하는 것이 서비스이다. 애플리케이션 전역의 관심사를 서비스로 분리하여 외부에서
 관리할 수 있다면 컴포넌트는 자신의 관심사에 집중할 수 있어 복잡도가 낮아지고 서비스는
 재사용이 가능하게 되어 일관된 애플리케이션 코드를 작성할 수 있다.

예를 들어, 뷰를 구성하기 위해 필요한 데이터를 서버로부터 취득하는 행위는 컴포넌트에 필요한 기능이지만, 
그 기능 자체가 컴포넌트의 주된 관심사는 아니다. 
이 기능은 다른 구성 요소들에도 필요한 공통 기능이기 때문에 애플리케이션 전역의 관심사로 구분할 수 있다.
 이러한 애플리케이션 공통 관심사를 서비스로 분리하면 구성 요소마다 자신의 관심사에 집중할 수 있어서
 구성 요소마다 자신의 관심사에 집중하는 독립성이 보장된 코드를 작성할 수 있게 된다. 
즉, 재사용성은 높아지고 복잡도는 낮출 수 있다.

## 의존성 주입
서비스는 의존성 주입(Dependency Injection)이 가능한 클래스이다. 

@Injectable 데코레이터는 자신의 아래에 정의된 클래스가 의존성 주입이 가능한(injectable) 클래스임을 나타낸다.

@Injectable 메타데이터 객체의 providedIn 프로퍼티는 Angular 6에서 새롭게 도입된 것으로 
프로퍼티 값으로 ‘root’를 설정하면 루트 인젝터에게 서비스를 제공하도록 지시하여 
애플리케이션의 모든 구성요소에 싱글턴 전역 서비스를 주입할 수 있도록 한다. 

Angular는 의존성 주입을 프레임워크 차원에서 지원한다. 

애플리케이션이 직접 인스턴스를 생성하는 것이 아니라 

Angular 프레임워크에게 의존성 인스턴스를 요구하고 프레임워크가 생성한 인스턴스를 전달받아 사용하는 방식이다.


의존성 주입을 사용하기 이전에는 컴포넌트가 직접 GreetingService의 인스턴스를 생성하였다. 

하지만 의존성 주입을 도입한 위 코드를 보면 컴포넌트가 GreetingService의 인스턴스를 직접 생성하지 않았다.

 다만 필요한 의존성을 constructor의 파라미터로 선언하여 의존성 인스턴스를 프레임워크에 요구했을 뿐이다.

의존성 주입을 사용하면 컴포넌트가 직접 의존성의 인스턴스를 생성하는 것이 아니라 

컴포넌트는 단지 필요한 의존성을 요구하고, 프레임워크가 제어권(Control)을 갖는 주체로 동작하여

 요구된 의존성 인스턴스를 생성하여 전달한다. 

이를 제어권의 역전(Inversion of Control, IoC)이라 한다.

서비스를 사용하는 구성요소(컴포넌트만이 서비스를 사용할 수 있는 것은 아니다. 모든 구성요소가 서비스를 사용할 수 있다.)

는 더 이상 의존성 인스턴스의 생성에 대해 관여하지 않아도 된다. 

Angular가 서비스의 인스턴스를 생성하여 컴포넌트에게 전달(주입, inject)해 줄 것이다. 

다만, 인스턴스를 어떻게 생성하는지 Angular는 알지 못하므로 이 정보를 Angular에 알려주어야 한다. 

다시 말해 주입될 의존성 인스턴스의 생성 정보를 Angular에 알려 주입을 지시하여야 한다. 

이러한 인스턴스 생성 정보를 설정하여 의존성 인스턴스의 주입을 지시하는 것을 프로바이더(provider)라고 부른다.


프로바이더는 서비스의 @Injectable 메타데이터 객체의 providedIn 프로퍼티 뿐만 아니라 컴포넌트의 
@Component와 모듈의 @NgModule 메타데이터 객체의 providers 프로퍼티에 등록할 수 있다.

@Injectable 메타데이터 객체의 providedIn 프로퍼티를 사용한 프로바이더의 설정은 Angular 6에서 

새롭게 도입된 기능이다. 

그런데 이 기능은 사실 기존의 프로바이더 설정 방식(@Component 또는 @NgModule 메타데이터 객체의
 providers 프로퍼티를 사용한 프로바이더의 설정)의 문법적 설탕이다. 

따라서 기존의 프로바이더 설정 방식을 이해하고 있으면 Angular 6의 새로운 기능도 쉽게 이해할 수 있을 것이다.

## Reference

튜토리얼주소
https://angular.kr/start/start-data

기본구조 주소
https://poiemaweb.com/angular-component-basics

웹 앱 개발자
https://gongcha.tistory.com/48

알고리즘 학습에 관한 조언
https://edykim.com/ko/post/advice-on-learning-algorithms/#%ED%91%9C%EC%A4%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9E%90%EB%A3%8C
